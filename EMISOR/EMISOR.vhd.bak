library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;

entity EMISOR is
    port(
        clk: in std_logic; -- 50MHz
        reset: in std_logic; -- reset
        data_in: in std_logic_vector(7 downto 0); -- datos a transmitir
        send: in std_logic; -- señal de control para iniciar transmisión
        tx: out std_logic -- salida al módulo HC-12
    );
end EMISOR;

architecture tx of EMISOR is
    -- Estados de la FSM
    type state_type is (IDLE, START, DATA, STOP);
    signal presentstate: state_type := IDLE;
    signal nextstate: state_type;

    -- Contadores y registros
    signal bit_index: std_logic_vector(3 downto 0) := "0000"; -- índice del bit
    signal baud_counter: std_logic_vector(9 downto 0) := (others => '0'); -- contador de baudrate
    signal baud_tick: std_logic := '0'; -- señal para generar ticks de baudrate
    signal tx_data: std_logic_vector(9 downto 0) := (others => '1'); -- datos serializados (start + data + stop)

begin
    -- Generador de ticks para el baudrate (9600 baudios)
    process (clk)
    begin
        if rising_edge(clk) then
            if baud_counter < "1101100100" then -- 868 ciclos (50MHz / 9600)
                baud_counter <= baud_counter + 1;
            else
                baud_counter <= (others => '0');
                baud_tick <= not baud_tick;
            end if;
        end if;
    end process;

    -- FSM de transmisión
    process (baud_tick, reset)
    begin
        if reset = '1' then
            presentstate <= IDLE;
            tx <= '1'; -- Línea en reposo (UART)
            bit_index <= "0000";
        elsif rising_edge(baud_tick) then
            presentstate <= nextstate;

            case presentstate is
                when IDLE =>
                    if send = '1' then
                        tx_data <= '0' & data_in & '1'; -- start + data + stop
                        bit_index <= "0000";
                        nextstate <= START;
                    else
                        nextstate <= IDLE;
                    end if;

                when START =>
                    tx <= tx_data(0); -- Enviar bit de inicio
                    nextstate <= DATA;

                when DATA =>
                    if bit_index < "1000" then
                        tx <= tx_data(to_integer(unsigned(bit_index)) + 1); -- Enviar bit de datos
                        bit_index <= bit_index + 1;
                        nextstate <= DATA;
                    else
                        nextstate <= STOP;
                    end if;

                when STOP =>
                    tx <= tx_data(9); -- Enviar bit de parada
                    nextstate <= IDLE;

                when others =>
                    nextstate <= IDLE;
            end case;
        end if;
    end process;

end tx;
